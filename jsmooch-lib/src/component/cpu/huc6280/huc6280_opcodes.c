#include <assert.h>
#include "helpers/int.h"
#include "huc6280_opcodes.h"
#include "huc6280.h"

// This file auto-generated byhuc6280_gen.py in JSMooCh

static void M6502_ins_NONE(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    assert(1==0);
}
// indirect_read_memory
static void HUC6280_ins_01_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_05_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_09_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->A | (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_0D_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_11_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_12_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_15_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_19_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_1D_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_21_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_25_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_29_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->A & (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_2D_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_31_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_32_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_35_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_39_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_3D_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_41_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_45_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_49_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->A ^ (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_4D_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_51_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_52_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_55_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_59_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_5D_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_61_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_65_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_69_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            i16 out = (i16)regs->A + (i16)(regs->TA) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TA)) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TA) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_6D_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_71_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_72_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_75_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->A = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_79_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_7D_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// operand
            regs->TA = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 4: {// operand
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


