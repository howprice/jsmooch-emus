#include <assert.h>
#include "helpers/int.h"
#include "huc6280_opcodes.h"
#include "huc6280.h"

// This file auto-generated byhuc6280_gen.py in JSMooCh

static void M6502_ins_NONE(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    assert(1==0);
}
// 
static void HUC6280_ins_00__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u | 0x10;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 6: {// push
            regs->P.T = 0; regs->P.D = 0; regs->P.I = 1;
            pins->Addr = regs->MPR[(0xFFF6)>>13] | ((0xFFF6) & 0x1FFF);
            pins->M = 1;
            break; }
        case 7: {// store8
            pins->M = 0;
            break; }
        case 8: {// load16
            regs->PC = pins->D;
            pins->Addr = regs->MPR[(0xFFF7)>>13] | ((0xFFF7) & 0x1FFF);
            pins->M = 1;
            regs->PC |= regs->TA << 8;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_01__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 7: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            break; }
        case 10: {// cleanup_custom
            regs->A = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_02__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// idle
            break; }
        case 2: {// idle
            regs->TA = regs->X;
            regs->X = regs->Y;
            regs->Y = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_03__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 2: {// store8
            pins->M = 0;
            break; }
        case 3: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = 0x1FE000;
            pins->D = regs->TR[0];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_04__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            u32 o = (regs->TR[0]) & regs->A;
            regs->P.Z = o == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->TR[1] = (regs->TR[0]) | regs->A;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_05__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_06__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_07__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// idle
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TR[0] &= ~(1 << 0);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_08__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_0A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// only!
            regs->P.C = ((regs->A) >> 7) & 1;
            regs->A = (regs->A << 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_0B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// yo
            // Following is auto-generated code for instruction finish
            break; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_00_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u | 0x10;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 6: {// push
            regs->P.T = 0; regs->P.D = 0; regs->P.I = 1;
            pins->Addr = regs->MPR[(0xFFF6)>>13] | ((0xFFF6) & 0x1FFF);
            pins->M = 1;
            break; }
        case 7: {// store8
            pins->M = 0;
            break; }
        case 8: {// load16
            regs->PC = pins->D;
            pins->Addr = regs->MPR[(0xFFF7)>>13] | ((0xFFF7) & 0x1FFF);
            pins->M = 1;
            regs->PC |= regs->TA << 8;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_01_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_02_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// idle
            break; }
        case 2: {// idle
            regs->TA = regs->X;
            regs->X = regs->Y;
            regs->Y = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_03_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 2: {// store8
            pins->M = 0;
            break; }
        case 3: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: {// idle
            pins->Addr = 0x1FE000;
            pins->D = regs->TR[0];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_04_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            u32 o = (regs->TR[0]) & regs->A;
            regs->P.Z = o == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->TR[1] = (regs->TR[0]) | regs->A;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_05_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_06_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_07_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
        case 1: {// store8
            pins->M = 0;
            break; }
        case 2: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {// idle
            break; }
        case 4: {// idle
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TR[0] &= ~(1 << 0);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            pins->RW = 1; pins->M = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_08_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_09_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->A | (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_0A_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// only!
            regs->P.C = ((regs->A) >> 7) & 1;
            regs->A = (regs->A << 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_0B_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// yo
            // Following is auto-generated code for instruction finish
            break; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->M = 1;
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_0D_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_11_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_12_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_15_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_19_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_1D_ORA_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_21_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_25_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_29_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->A & (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_2D_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_31_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_32_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_35_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_39_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_3D_AND_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_41_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_45_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_49_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->A ^ (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_4D_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_51_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_52_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_55_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_59_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_5D_EOR_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_61_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 11: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 12: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_65_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// immediate_memory
static void HUC6280_ins_69_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            i16 out = (i16)regs->A + (i16)(regs->TA) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TA)) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TA) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_6D_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 10: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_71_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 11: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 12: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_72_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->TR[0] = pins->D;
            pins->M = 0;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 7: {// load8
            regs->TR[1] = pins->D;
            pins->M = 0;
            break; }
        case 8: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 9: {// store8
            pins->M = 0;
            break; }
        case 10: {// load16
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 11: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 12: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_75_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 5: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->M = 1;
            break; }
        case 6: {// load8
            regs->A = pins->D;
            pins->M = 0;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_79_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 10: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


// 
static void HUC6280_ins_7D_ADC_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start!
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->M = 1;
            break; }
        case 2: {// load8
            regs->A = pins->D;
            pins->M = 0;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 3: {// store8
            pins->M = 0;
            break; }
        case 4: {// operand
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->M = 1;
            break; }
        case 5: {// store8
            pins->M = 0;
            break; }
        case 6: {// operand
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            break; }
        case 7: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->M = 1;
            break; }
        case 8: {// store8
            pins->M = 0;
            break; }
        case 9: {// load16
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = (out >> 8) & 1;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A & out)) >> 7) & 1;
                regs->TCU++;
            }
            else {
                u8 lo = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (lo > 9) out += 6;
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
            }
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            break; }
        case 10: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            pins->RW = 1; pins->M = 1;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            break; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0; 
            regs->P.T = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
        }
    }
}


